# formタグ

## メソッドの違い  
* GETはデータベースを介さない、POSTはデータベースを介す  
* GETは送信内容をURLに含む、POSTは送信内容をURLに含まない  
* 秘匿性の高いことはPOSTを使うと良い  
* URLは文字数制限があるため、データ量が多い場合はPOSTを使うと良い  

## action属性  
そのformからデータを送信する場所。  

## name属性  
そのinputタグから送信されるデータにつく識別名。  
nameを出力時や問い合わせ時に指定することで
そのinputから送信されたデータを呼び出すことができる。  

#### 自分なりに考える  
name属性は変数ではないのでデータベースに保存する動作がない限り、
複数のデータを保持することは多分できない。
別のブラウザから違う内容を同時に送信したり出力することはできるが、
別のブラウザで送信した内容を呼び出すことは難しいと思う。
同じブラウザでひとつ前に送信した内容を呼び出すのも難しい気がする。  

## labelタグ
labelタグのfor属性と、inputタグのid属性を同一にすることで
inputタグにつけるlabelを指定することができる。  

## form_withから生成されるinputタグのname属性について  
https://qiita.com/aimaimi/items/ddba89111e2e604130cc  
https://railsdoc.com/page/form_with  

指定しない場合は自動生成される。
action属性にurlのみを指定すると`:hoge`なら`name="hoge", id="hoge"`になる。  
その他モデルやスコープの指定をしている場合は、
`name="model[hoge]", id="model_hoge"`のようになる。 
モデル[シンボル]のような感じ。  

## form_withを理解する
form_withはインスタンス変数が空かどうかでaction属性を振り分ける。  
レコードが新しいかどうかをrecord.persisted?で識別するらしい。  
form_withののちにaction属性に代わる部分が空かどうか。  
そのページを表示するにあたり踏んできたアクションの中でセットされているかどうか。  
https://qiita.com/okonomi/items/6c2b31427161090c173a 

## paramsについて
### form_for的な使い方
関連するモデルがない場合(form_withの時点でURL指定する場合)  
`params[:email]`で取得する。  
ストロングパラメータ(フォームから受け取る内容を決めるやつ)は
`params.permit(:email)`で指定できる。  
### form_with的な使い方
関連するモデルがある場合(form_withの時点で`model: @user`の場合)  
`params[:user][:email]`で取得する。  
ストロングパラメータは
`paramas.requie(:user).permit(:email)`で指定できる。  
階層構造にする必要がある。モデルを一回挟む。というか指定する感じ。  

https://qiita.com/snskOgata/items/44d32a06045e6a52d11c  

## authenticity_tokenについて
https://takkuso.hatenablog.com/entry/2019/03/18/224252  
https://tech-essentials.work/course_outputs/201  
CSRF対策用の自動生成トークン。 
CSRFについては別ページのnoteあり。  
フォームのあるページを開くと自動で生成される。リロードすると変わる。  
生成し、セッションに保存してフォームに隠す。(`input type="hiden"`)  
フォームが送信されるとセッションに保存されたトークンと
送信されたトークンが一致するか確認する。  
一致すればフォームの内容を正しく扱う。  
ユーザーや開発者が意図した通りにという意味で。  
データベースに保存したり表示したり。  



--20221008, 20221125, 20221126, 20221203

---

# フォーム事件
フォームの送信とHTTPリクエストは別物だと思っていた。  
というか、完全に分かっていなかったわけではなくうまく点と点がくっついていなかった感じ。  
文字にしてみると矛盾しているけど、
ただ頭の中に忠実に、めちゃくちゃなことを書きます。  

## フォームの認識
### 正しく認識していたこと
* action属性があり、フォームから送るデータを送信したいURLを指定する
* method属性があり、HTTPリクエストのメソッドを指定する
* GETならURLに入力内容が含まれる
* POSTなら入力内容はリクエストボディに含まれる  
### 誤って認識していたこと
* 入力してsubmitすると送信されるけどルーティングとは関係ない
* HTTPリクエストとは別の独自の送信をする
* action属性もmethod属性もフォーム独自のもの

ルーティングとは関係ないと思っていたのでaction属性のページに向けて、
GETもしくはPOSTを使って独自に送信していると思っていた。  
action属性で指定したURLのページに透明な領域があり、
そこがフォームを受け取る専用だと思っていた。  
単なるHTTPリクエストのGET/POSTとは別に、
フォーム独自の送信方法としてGET/POSTがあると思っていた。
書いていて自分でも意味がわからないがこれ以上説明できない。

## HTTPリクエストをもう一度考える
フォームタグで指定したURLにフォームタグで指定したHTTPリクエストメソッドが
送られる。
HTTPリクエストにくっつくのがフォームの入力内容（パラメーター）。
ここまでは理解していたこと。
### どうしたらHTTPリクエストが発生するのか
これを深く考えていなかった。
* フォームをsubmitする
* URLリンクやリンク付きのテキストを押す
* URLを直接入力してEnter押す
https://dev-lib.com/http-request-response/  

これも知らなかったわけではないが頭の中になかった。
フォームのaction属性とmethod属性がフォーム独自のものと切り離して考えていたため。  


## まとめ
1. submitするとHTTPリクエストが発生する
2. そのHTTPリクエストはフォームのaction属性とmethod属性をもとにしたもの
3. つまりフォームのaction属性とmethod属性に当てはまるルーティングを参照することになる
4. ルーティングで指定されたコントローラのアクションを実行する

こんな感じかな！間違いあれば修正します。

--20221130, 20221202